// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessToken {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub expires_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub expires_in: ::core::option::Option<::pbjson_types::Duration>,
    #[prost(string, tag = "4")]
    pub owner_account_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub linked_account_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginRequest {
    #[prost(oneof = "login_request::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<login_request::Type>,
}
/// Nested message and enum types in `LoginRequest`.
pub mod login_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuthorizationCodeGrant {
        #[prost(string, tag = "1")]
        pub client_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub authorization_code: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceCodeGrant {
        #[prost(string, tag = "1")]
        pub client_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub device_code: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RefreshTokenGrant {
        #[prost(string, tag = "1")]
        pub refresh_token: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        AuthorizationCodeGrant(AuthorizationCodeGrant),
        #[prost(message, tag = "2")]
        DeviceCodeGrant(DeviceCodeGrant),
        #[prost(message, tag = "3")]
        RefreshTokenGrant(RefreshTokenGrant),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginResponse {
    #[prost(message, optional, tag = "1")]
    pub access_token: ::core::option::Option<AccessToken>,
    #[prost(string, optional, tag = "2")]
    pub refresh_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(string, repeated, tag = "5")]
    pub linked_account_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub service_instance_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub project_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub default_project_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "9")]
    pub ssh_key_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "account::Owner", tags = "106")]
    pub owner: ::core::option::Option<account::Owner>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorObject {
    /// ID is a unique identifier for this particular occurrence of a problem.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Title is a short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    /// Detail is a human-readable explanation specific to this occurrence of the problem. Like title, this fieldâ€™s value can be localized.
    #[prost(string, tag = "3")]
    pub detail: ::prost::alloc::string::String,
    /// Status is the HTTP status code applicable to this problem, expressed as a string value.
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
    /// Code is an application-specific error code, expressed as a string value.
    #[prost(string, tag = "5")]
    pub code: ::prost::alloc::string::String,
    /// Metadata is an object containing non-standard meta-information about the error.
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorObjects {
    #[prost(message, repeated, tag = "1")]
    pub error_object: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindAccountRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyAccountsRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<AccountFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyAccountsResponse {
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<Account>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateAccountResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiKey {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub private_key: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "api_key::Owner", tags = "106")]
    pub owner: ::core::option::Option<api_key::Owner>,
}
/// Nested message and enum types in `ApiKey`.
pub mod api_key {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiKeyFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApiKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub api_key: ::core::option::Option<ApiKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApiKeyResponse {
    #[prost(message, optional, tag = "1")]
    pub api_key: ::core::option::Option<ApiKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteApiKeyRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteApiKeyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindApiKeyRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindApiKeyResponse {
    #[prost(message, optional, tag = "1")]
    pub api_key: ::core::option::Option<ApiKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyApiKeysRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<ApiKeyFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyApiKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub api_keys: ::prost::alloc::vec::Vec<ApiKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApiKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub api_key: ::core::option::Option<ApiKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApiKeyResponse {
    #[prost(message, optional, tag = "1")]
    pub api_key: ::core::option::Option<ApiKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateApiKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub api_key: ::core::option::Option<ApiKey>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateApiKeyResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckoutSession {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub plan_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub existing_service_instance_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "checkout_session::Owner", tags = "106")]
    pub owner: ::core::option::Option<checkout_session::Owner>,
}
/// Nested message and enum types in `CheckoutSession`.
pub mod checkout_session {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCheckoutSessionRequest {
    #[prost(message, optional, tag = "1")]
    pub checkout_session: ::core::option::Option<CheckoutSession>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCheckoutSessionResponse {
    #[prost(message, optional, tag = "1")]
    pub checkout_session: ::core::option::Option<CheckoutSession>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCheckoutSessionRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteCheckoutSessionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindCheckoutSessionRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindCheckoutSessionResponse {
    #[prost(message, optional, tag = "1")]
    pub checkout_session: ::core::option::Option<CheckoutSession>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCheckoutSessionRequest {
    #[prost(message, optional, tag = "1")]
    pub checkout_session: ::core::option::Option<CheckoutSession>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCheckoutSessionResponse {
    #[prost(message, optional, tag = "1")]
    pub checkout_session: ::core::option::Option<CheckoutSession>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateCheckoutSessionRequest {
    #[prost(message, optional, tag = "1")]
    pub checkout_session: ::core::option::Option<CheckoutSession>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateCheckoutSessionResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub length: u32,
    #[prost(string, tag = "3")]
    pub filename: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "file_info::Owner", tags = "106")]
    pub owner: ::core::option::Option<file_info::Owner>,
}
/// Nested message and enum types in `FileInfo`.
pub mod file_info {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfoFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub owner_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub length: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub hash_sha256: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFileRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteFileResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadFileRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadFileResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub chunk: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindFileRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindFileResponse {
    #[prost(message, optional, tag = "1")]
    pub file_info: ::core::option::Option<FileInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyFilesRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<FileInfoFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub file_infos: ::prost::alloc::vec::Vec<FileInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFileRequest {
    #[prost(message, optional, tag = "1")]
    pub file_info: ::core::option::Option<FileInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFileResponse {
    #[prost(message, optional, tag = "1")]
    pub file_info: ::core::option::Option<FileInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadFileRequest {
    #[prost(oneof = "upload_file_request::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<upload_file_request::Type>,
}
/// Nested message and enum types in `UploadFileRequest`.
pub mod upload_file_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        FileInfo(super::FileInfo),
        #[prost(bytes, tag = "2")]
        Chunk(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadFileResponse {
    #[prost(message, optional, tag = "1")]
    pub file_info: ::core::option::Option<FileInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(oneof = "generate_request::Snapshot", tags = "2, 3")]
    pub snapshot: ::core::option::Option<generate_request::Snapshot>,
    #[prost(oneof = "generate_request::What", tags = "4, 5, 6, 7, 8")]
    pub what: ::core::option::Option<generate_request::What>,
}
/// Nested message and enum types in `GenerateRequest`.
pub mod generate_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Archive {
        #[prost(string, repeated, tag = "1")]
        pub file_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Controller {
        #[prost(string, tag = "1")]
        pub resource: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub service: ::prost::alloc::string::String,
        #[prost(uint32, tag = "3")]
        pub version: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Field {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, optional, tag = "2")]
        pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GitCommit {
        #[prost(string, tag = "1")]
        pub hash: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Init {
        #[prost(string, tag = "1")]
        pub brand: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Model {
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
        #[prost(uint32, tag = "2")]
        pub version: u32,
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub fields: ::prost::alloc::vec::Vec<Field>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Resource {
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
        #[prost(uint32, tag = "2")]
        pub version: u32,
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub fields: ::prost::alloc::vec::Vec<Field>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Service {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(uint32, tag = "2")]
        pub version: u32,
        #[prost(bool, tag = "3")]
        pub with_cli: bool,
        #[prost(string, repeated, tag = "4")]
        pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Snapshot {
        #[prost(message, tag = "2")]
        GitCommit(GitCommit),
        #[prost(message, tag = "3")]
        Archive(Archive),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum What {
        #[prost(message, tag = "4")]
        Init(Init),
        #[prost(message, tag = "5")]
        Controller(Controller),
        #[prost(message, tag = "6")]
        Model(Model),
        #[prost(message, tag = "7")]
        Resource(Resource),
        #[prost(message, tag = "8")]
        Service(Service),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateResponse {
    #[prost(string, tag = "1")]
    pub file_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Plan {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub service_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(bool, optional, tag = "6")]
    pub free: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub bindable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub binding_rotatable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub plan_updateable: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "plan::Owner", tags = "106")]
    pub owner: ::core::option::Option<plan::Owner>,
}
/// Nested message and enum types in `Plan`.
pub mod plan {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub bindable: bool,
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub requires: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "8")]
    pub plan_updateable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub instances_retrievable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub bindings_retrievable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub allow_context_updates: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "12")]
    pub plan_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "service::Owner", tags = "106")]
    pub owner: ::core::option::Option<service::Owner>,
}
/// Nested message and enum types in `Service`.
pub mod service {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportRequest {
    #[prost(bool, tag = "1")]
    pub dry_run: bool,
    #[prost(message, repeated, tag = "2")]
    pub services: ::prost::alloc::vec::Vec<Service>,
    #[prost(message, repeated, tag = "3")]
    pub plans: ::prost::alloc::vec::Vec<Plan>,
    #[prost(message, repeated, tag = "4")]
    pub accounts: ::prost::alloc::vec::Vec<Account>,
    #[prost(message, repeated, tag = "5")]
    pub api_keys: ::prost::alloc::vec::Vec<ApiKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportResponse {
    #[prost(bool, tag = "1")]
    pub dry_run: bool,
    #[prost(message, optional, tag = "2")]
    pub adds: ::core::option::Option<import_response::Adds>,
    #[prost(message, optional, tag = "3")]
    pub deletes: ::core::option::Option<import_response::Deletes>,
    #[prost(message, optional, tag = "4")]
    pub updates: ::core::option::Option<import_response::Updates>,
    #[prost(message, optional, tag = "5")]
    pub validation_errors: ::core::option::Option<import_response::ValidationErrors>,
}
/// Nested message and enum types in `ImportResponse`.
pub mod import_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Adds {
        #[prost(string, repeated, tag = "1")]
        pub service_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub plan_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub api_key_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub account_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Deletes {
        #[prost(string, repeated, tag = "1")]
        pub service_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub plan_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub api_key_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub account_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Updates {
        #[prost(string, repeated, tag = "1")]
        pub service_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub plan_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub api_key_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub account_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ValidationErrors {
        #[prost(map = "string, message", tag = "1")]
        pub service_errors: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ErrorObjects,
        >,
        #[prost(map = "string, message", tag = "2")]
        pub plan_errors: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ErrorObjects,
        >,
        #[prost(map = "string, message", tag = "3")]
        pub api_key_errors: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ErrorObjects,
        >,
        #[prost(map = "string, message", tag = "4")]
        pub account_errors: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ErrorObjects,
        >,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Invite {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "invite::Type", tag = "2")]
    pub r#type: i32,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub recipient_email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "invite::Owner", tags = "106")]
    pub owner: ::core::option::Option<invite::Owner>,
}
/// Nested message and enum types in `Invite`.
pub mod invite {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "Unknown",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unknown" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InviteFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub recipient_email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "invite::Type", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInviteRequest {
    #[prost(message, optional, tag = "1")]
    pub invite: ::core::option::Option<Invite>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInviteResponse {
    #[prost(message, optional, tag = "1")]
    pub invite: ::core::option::Option<Invite>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInviteRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteInviteResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindInviteRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindInviteResponse {
    #[prost(message, optional, tag = "1")]
    pub invite: ::core::option::Option<Invite>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyInvitesRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<InviteFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyInvitesResponse {
    #[prost(message, repeated, tag = "1")]
    pub invites: ::prost::alloc::vec::Vec<Invite>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInviteRequest {
    #[prost(message, optional, tag = "1")]
    pub invite: ::core::option::Option<Invite>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInviteResponse {
    #[prost(message, optional, tag = "1")]
    pub invite: ::core::option::Option<Invite>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateInviteRequest {
    #[prost(message, optional, tag = "1")]
    pub invite: ::core::option::Option<Invite>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateInviteResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueComment {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub issue_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1000")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1001")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "1002")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1003")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "1004")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1005")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "issue_comment::Owner", tags = "1006")]
    pub owner: ::core::option::Option<issue_comment::Owner>,
}
/// Nested message and enum types in `IssueComment`.
pub mod issue_comment {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "1006")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueCommentFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub issue_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueCommentRequest {
    #[prost(message, optional, tag = "1")]
    pub issue_comment: ::core::option::Option<IssueComment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueCommentResponse {
    #[prost(message, optional, tag = "1")]
    pub issue_comment: ::core::option::Option<IssueComment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueCommentRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteIssueCommentResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindIssueCommentRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindIssueCommentResponse {
    #[prost(message, optional, tag = "1")]
    pub issue_comment: ::core::option::Option<IssueComment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyIssueCommentsRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<IssueCommentFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyIssueCommentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub issue_comments: ::prost::alloc::vec::Vec<IssueComment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueCommentRequest {
    #[prost(message, optional, tag = "1")]
    pub issue_comment: ::core::option::Option<IssueComment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueCommentResponse {
    #[prost(message, optional, tag = "1")]
    pub issue_comment: ::core::option::Option<IssueComment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateIssueCommentRequest {
    #[prost(message, optional, tag = "1")]
    pub issue_comment: ::core::option::Option<IssueComment>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateIssueCommentResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Issue {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(enumeration = "issue::Type", tag = "3")]
    pub r#type: i32,
    #[prost(enumeration = "issue::State", tag = "4")]
    pub state: i32,
    #[prost(string, optional, tag = "5")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub file_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub issue_comment_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "issue::Owner", tags = "106")]
    pub owner: ::core::option::Option<issue::Owner>,
}
/// Nested message and enum types in `Issue`.
pub mod issue {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Open = 0,
        Closed = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Open => "Open",
                Self::Closed => "Closed",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Open" => Some(Self::Open),
                "Closed" => Some(Self::Closed),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Bug = 0,
        Question = 1,
        Suggestion = 2,
        FeatureRequest = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Bug => "Bug",
                Self::Question => "Question",
                Self::Suggestion => "Suggestion",
                Self::FeatureRequest => "FeatureRequest",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Bug" => Some(Self::Bug),
                "Question" => Some(Self::Question),
                "Suggestion" => Some(Self::Suggestion),
                "FeatureRequest" => Some(Self::FeatureRequest),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub owner_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "issue::Type", optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueRequest {
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueResponse {
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteIssueResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindIssueRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindIssueResponse {
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyIssuesRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<IssueFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyIssuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub issues: ::prost::alloc::vec::Vec<Issue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueRequest {
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueResponse {
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateIssueRequest {
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateIssueResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkedAccount {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "linked_account::Type", tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "linked_account::Provider", tag = "3")]
    pub provider: i32,
    #[prost(string, tag = "4")]
    pub provider_uid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "linked_account::Owner", tags = "106")]
    pub owner: ::core::option::Option<linked_account::Owner>,
}
/// Nested message and enum types in `LinkedAccount`.
pub mod linked_account {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Provider {
        GitHub = 0,
        GitLab = 1,
        Stripe = 2,
    }
    impl Provider {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GitHub => "GitHub",
                Self::GitLab => "GitLab",
                Self::Stripe => "Stripe",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GitHub" => Some(Self::GitHub),
                "GitLab" => Some(Self::GitLab),
                "Stripe" => Some(Self::Stripe),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        IdentityProvider = 0,
        PaymentProvider = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::IdentityProvider => "IdentityProvider",
                Self::PaymentProvider => "PaymentProvider",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IdentityProvider" => Some(Self::IdentityProvider),
                "PaymentProvider" => Some(Self::PaymentProvider),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkedAccountFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub owner_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub provider_uid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "linked_account::Type", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(enumeration = "linked_account::Provider", optional, tag = "5")]
    pub provider: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLinkedAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub linked_account: ::core::option::Option<LinkedAccount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLinkedAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub linked_account: ::core::option::Option<LinkedAccount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLinkedAccountRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteLinkedAccountResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindLinkedAccountRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindLinkedAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub linked_account: ::core::option::Option<LinkedAccount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyLinkedAccountsRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<LinkedAccountFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyLinkedAccountsResponse {
    #[prost(message, repeated, tag = "1")]
    pub linked_accounts: ::prost::alloc::vec::Vec<LinkedAccount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateLinkedAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub linked_account: ::core::option::Option<LinkedAccount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateLinkedAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub linked_account: ::core::option::Option<LinkedAccount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateLinkedAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub linked_account: ::core::option::Option<LinkedAccount>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateLinkedAccountResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub service_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePlanRequest {
    #[prost(message, optional, tag = "1")]
    pub plan: ::core::option::Option<Plan>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePlanResponse {
    #[prost(message, optional, tag = "1")]
    pub plan: ::core::option::Option<Plan>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePlanRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeletePlanResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindPlanRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindPlanResponse {
    #[prost(message, optional, tag = "1")]
    pub plan: ::core::option::Option<Plan>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyPlansRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<PlanFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyPlansResponse {
    #[prost(message, repeated, tag = "1")]
    pub plans: ::prost::alloc::vec::Vec<Plan>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePlanRequest {
    #[prost(message, optional, tag = "1")]
    pub plan: ::core::option::Option<Plan>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePlanResponse {
    #[prost(message, optional, tag = "1")]
    pub plan: ::core::option::Option<Plan>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatePlanRequest {
    #[prost(message, optional, tag = "1")]
    pub plan: ::core::option::Option<Plan>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
    #[prost(string, repeated, tag = "3")]
    pub ignore_missing_service_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatePlanResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1000")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1001")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "1002")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1003")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "1004")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1005")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "project::Owner", tags = "1006")]
    pub owner: ::core::option::Option<project::Owner>,
}
/// Nested message and enum types in `Project`.
pub mod project {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "1006")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub owner_account_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProjectRequest {
    #[prost(message, optional, tag = "1")]
    pub project: ::core::option::Option<Project>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProjectResponse {
    #[prost(message, optional, tag = "1")]
    pub project: ::core::option::Option<Project>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteProjectRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteProjectResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindProjectRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindProjectResponse {
    #[prost(message, optional, tag = "1")]
    pub project: ::core::option::Option<Project>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyProjectsRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<ProjectFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyProjectsResponse {
    #[prost(message, repeated, tag = "1")]
    pub projects: ::prost::alloc::vec::Vec<Project>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProjectRequest {
    #[prost(message, optional, tag = "1")]
    pub project: ::core::option::Option<Project>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProjectResponse {
    #[prost(message, optional, tag = "1")]
    pub project: ::core::option::Option<Project>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateProjectRequest {
    #[prost(message, optional, tag = "1")]
    pub project: ::core::option::Option<Project>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateProjectResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetServerInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerInfoResponse {
    #[prost(map = "string, string", tag = "1")]
    pub oauth_client_ids: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceInstance {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub service_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub plan_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(string, optional, tag = "5")]
    pub stripe_subscription_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "100")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "101")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "102")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "103")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "105")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "service_instance::Owner", tags = "106")]
    pub owner: ::core::option::Option<service_instance::Owner>,
}
/// Nested message and enum types in `ServiceInstance`.
pub mod service_instance {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "106")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceInstanceFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub plan_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub service_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub service_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub owner_account_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceInstanceRequest {
    #[prost(message, optional, tag = "1")]
    pub service_instance: ::core::option::Option<ServiceInstance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceInstanceResponse {
    #[prost(message, optional, tag = "1")]
    pub service_instance: ::core::option::Option<ServiceInstance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServiceInstanceRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteServiceInstanceResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindServiceInstanceRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindServiceInstanceResponse {
    #[prost(message, optional, tag = "1")]
    pub service_instance: ::core::option::Option<ServiceInstance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyServiceInstancesRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<ServiceInstanceFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyServiceInstancesResponse {
    #[prost(message, repeated, tag = "1")]
    pub service_instances: ::prost::alloc::vec::Vec<ServiceInstance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceInstanceRequest {
    #[prost(message, optional, tag = "1")]
    pub service_instance: ::core::option::Option<ServiceInstance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceInstanceResponse {
    #[prost(message, optional, tag = "1")]
    pub service_instance: ::core::option::Option<ServiceInstance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateServiceInstanceRequest {
    #[prost(message, optional, tag = "1")]
    pub service_instance: ::core::option::Option<ServiceInstance>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateServiceInstanceResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub tag: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceRequest {
    #[prost(message, optional, tag = "1")]
    pub service: ::core::option::Option<Service>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServiceResponse {
    #[prost(message, optional, tag = "1")]
    pub service: ::core::option::Option<Service>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServiceRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteServiceResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindServiceRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindServiceResponse {
    #[prost(message, optional, tag = "1")]
    pub service: ::core::option::Option<Service>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyServicesRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<ServiceFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManyServicesResponse {
    #[prost(message, repeated, tag = "1")]
    pub services: ::prost::alloc::vec::Vec<Service>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceRequest {
    #[prost(message, optional, tag = "1")]
    pub service: ::core::option::Option<Service>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServiceResponse {
    #[prost(message, optional, tag = "1")]
    pub service: ::core::option::Option<Service>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateServiceRequest {
    #[prost(message, optional, tag = "1")]
    pub service: ::core::option::Option<Service>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateServiceResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SshKey {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub fingerprint: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub public_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1000")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1001")]
    pub created_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "1002")]
    pub deleted_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1003")]
    pub deleted_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "1004")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, optional, tag = "1005")]
    pub updated_by_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "ssh_key::Owner", tags = "1006")]
    pub owner: ::core::option::Option<ssh_key::Owner>,
}
/// Nested message and enum types in `SshKey`.
pub mod ssh_key {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        #[prost(string, tag = "1006")]
        OwnerAccountId(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SshKeyFilter {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSshKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub ssh_key: ::core::option::Option<SshKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSshKeyResponse {
    #[prost(message, optional, tag = "1")]
    pub ssh_key: ::core::option::Option<SshKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSshKeyRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSshKeyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindSshKeyRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindSshKeyResponse {
    #[prost(message, optional, tag = "1")]
    pub ssh_key: ::core::option::Option<SshKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManySshKeysRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<SshKeyFilter>,
    #[prost(message, optional, tag = "2")]
    pub field_mask: ::core::option::Option<::pbjson_types::FieldMask>,
    #[prost(uint32, optional, tag = "3")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindManySshKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub ssh_keys: ::prost::alloc::vec::Vec<SshKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSshKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub ssh_key: ::core::option::Option<SshKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSshKeyResponse {
    #[prost(message, optional, tag = "1")]
    pub ssh_key: ::core::option::Option<SshKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateSshKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub ssh_key: ::core::option::Option<SshKey>,
    #[prost(bool, tag = "2")]
    pub existing: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateSshKeyResponse {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<ErrorObject>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoopRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoopResponse {}
/// Generated client implementations.
pub mod user_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct UserClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn create_account(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_api_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateApiKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateApiKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateApiKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_checkout_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCheckoutSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateCheckoutSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "CreateCheckoutSession"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_invite(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateInviteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateInvite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateInvite"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateIssueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateIssue"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateIssueCommentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateIssueComment"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_linked_account(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateLinkedAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateLinkedAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateLinkedAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreatePlanResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreatePlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreatePlan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_project(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateProject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_service(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateServiceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateService"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_service_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateServiceInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateServiceInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "CreateServiceInstance"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_ssh_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSshKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/CreateSshKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "CreateSshKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_api_key(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteApiKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteApiKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteApiKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_checkout_session(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteCheckoutSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteCheckoutSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "DeleteCheckoutSession"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteFile"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_invite(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteInviteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteInvite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteInvite"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteIssueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteIssue"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteIssueCommentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteIssueComment"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_linked_account(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteLinkedAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteLinkedAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteLinkedAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePlanResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeletePlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeletePlan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_project(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteProject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_service(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteServiceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteService"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_service_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteServiceInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteServiceInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "DeleteServiceInstance"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_ssh_key(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteSshKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DeleteSshKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DeleteSshKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_account(
            &mut self,
            request: impl tonic::IntoRequest<super::FindAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_api_key(
            &mut self,
            request: impl tonic::IntoRequest<super::FindApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindApiKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindApiKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindApiKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_checkout_session(
            &mut self,
            request: impl tonic::IntoRequest<super::FindCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindCheckoutSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindCheckoutSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindCheckoutSession"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_file(
            &mut self,
            request: impl tonic::IntoRequest<super::FindFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindFile"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_invite(
            &mut self,
            request: impl tonic::IntoRequest<super::FindInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindInviteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindInvite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindInvite"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::FindIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindIssueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindIssue"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::FindIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindIssueCommentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindIssueComment"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_linked_account(
            &mut self,
            request: impl tonic::IntoRequest<super::FindLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindLinkedAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindLinkedAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindLinkedAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::FindPlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindPlanResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindPlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindPlan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_project(
            &mut self,
            request: impl tonic::IntoRequest<super::FindProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindProject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_service(
            &mut self,
            request: impl tonic::IntoRequest<super::FindServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindServiceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindService"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_service_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::FindServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindServiceInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindServiceInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindServiceInstance"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_ssh_key(
            &mut self,
            request: impl tonic::IntoRequest<super::FindSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindSshKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindSshKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindSshKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyAccounts"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_api_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyApiKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyApiKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyApiKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyApiKeys"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_files(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyFilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyFilesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyFiles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyFiles"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_invites(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyInvitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyInvitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyInvites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyInvites"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_issue_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyIssueCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyIssueCommentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyIssueComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "FindManyIssueComments"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_issues(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyIssuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyIssuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyIssues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyIssues"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_linked_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyLinkedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyLinkedAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyLinkedAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "FindManyLinkedAccounts"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_plans(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyPlansRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyPlansResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyPlans",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyPlans"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_projects(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyProjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyProjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyProjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyProjects"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_service_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyServiceInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyServiceInstancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyServiceInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "FindManyServiceInstances"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_services(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManyServicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyServicesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManyServices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManyServices"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_many_ssh_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::FindManySshKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManySshKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/FindManySshKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "FindManySshKeys"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn generate(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/Generate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "Generate"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_server_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServerInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServerInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/GetServerInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "GetServerInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn import(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/Import",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "Import"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn login(
            &mut self,
            request: impl tonic::IntoRequest<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/Login",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "Login"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn noop(
            &mut self,
            request: impl tonic::IntoRequest<super::NoopRequest>,
        ) -> std::result::Result<tonic::Response<super::NoopResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/Noop",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("saas_rs.user.v1.User", "Noop"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_account(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_api_key(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateApiKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateApiKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateApiKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_checkout_session(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateCheckoutSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateCheckoutSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "UpdateCheckoutSession"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_file(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateFile"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_invite(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateInviteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateInvite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateInvite"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateIssueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateIssue"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateIssueCommentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateIssueComment"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_linked_account(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateLinkedAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateLinkedAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateLinkedAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePlanResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdatePlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdatePlan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_project(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateProject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_service(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateServiceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateService"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_service_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateServiceInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateServiceInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "UpdateServiceInstance"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_ssh_key(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateSshKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UpdateSshKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UpdateSshKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_account(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_api_key(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateApiKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateApiKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateApiKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_checkout_session(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateCheckoutSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateCheckoutSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "ValidateCheckoutSession"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_invite(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateInviteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateInvite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateInvite"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateIssueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateIssue"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateIssueCommentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateIssueComment"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_linked_account(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateLinkedAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateLinkedAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "ValidateLinkedAccount"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidatePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidatePlanResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidatePlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidatePlan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_project(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateProject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_service(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateServiceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateService"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_service_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateServiceInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateServiceInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("saas_rs.user.v1.User", "ValidateServiceInstance"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_ssh_key(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateSshKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/ValidateSshKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "ValidateSshKey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn download_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DownloadFileRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DownloadFileResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/DownloadFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "DownloadFile"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn upload_file(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::UploadFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/saas_rs.user.v1.User/UploadFile",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("saas_rs.user.v1.User", "UploadFile"));
            self.inner.client_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod user_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with UserServer.
    #[async_trait]
    pub trait User: std::marker::Send + std::marker::Sync + 'static {
        async fn create_account(
            &self,
            request: tonic::Request<super::CreateAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateAccountResponse>,
            tonic::Status,
        >;
        async fn create_api_key(
            &self,
            request: tonic::Request<super::CreateApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateApiKeyResponse>,
            tonic::Status,
        >;
        async fn create_checkout_session(
            &self,
            request: tonic::Request<super::CreateCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCheckoutSessionResponse>,
            tonic::Status,
        >;
        async fn create_invite(
            &self,
            request: tonic::Request<super::CreateInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateInviteResponse>,
            tonic::Status,
        >;
        async fn create_issue(
            &self,
            request: tonic::Request<super::CreateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateIssueResponse>,
            tonic::Status,
        >;
        async fn create_issue_comment(
            &self,
            request: tonic::Request<super::CreateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateIssueCommentResponse>,
            tonic::Status,
        >;
        async fn create_linked_account(
            &self,
            request: tonic::Request<super::CreateLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateLinkedAccountResponse>,
            tonic::Status,
        >;
        async fn create_plan(
            &self,
            request: tonic::Request<super::CreatePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreatePlanResponse>,
            tonic::Status,
        >;
        async fn create_project(
            &self,
            request: tonic::Request<super::CreateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProjectResponse>,
            tonic::Status,
        >;
        async fn create_service(
            &self,
            request: tonic::Request<super::CreateServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateServiceResponse>,
            tonic::Status,
        >;
        async fn create_service_instance(
            &self,
            request: tonic::Request<super::CreateServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateServiceInstanceResponse>,
            tonic::Status,
        >;
        async fn create_ssh_key(
            &self,
            request: tonic::Request<super::CreateSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSshKeyResponse>,
            tonic::Status,
        >;
        async fn delete_api_key(
            &self,
            request: tonic::Request<super::DeleteApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteApiKeyResponse>,
            tonic::Status,
        >;
        async fn delete_checkout_session(
            &self,
            request: tonic::Request<super::DeleteCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteCheckoutSessionResponse>,
            tonic::Status,
        >;
        async fn delete_file(
            &self,
            request: tonic::Request<super::DeleteFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteFileResponse>,
            tonic::Status,
        >;
        async fn delete_invite(
            &self,
            request: tonic::Request<super::DeleteInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteInviteResponse>,
            tonic::Status,
        >;
        async fn delete_issue(
            &self,
            request: tonic::Request<super::DeleteIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteIssueResponse>,
            tonic::Status,
        >;
        async fn delete_issue_comment(
            &self,
            request: tonic::Request<super::DeleteIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteIssueCommentResponse>,
            tonic::Status,
        >;
        async fn delete_linked_account(
            &self,
            request: tonic::Request<super::DeleteLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteLinkedAccountResponse>,
            tonic::Status,
        >;
        async fn delete_plan(
            &self,
            request: tonic::Request<super::DeletePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePlanResponse>,
            tonic::Status,
        >;
        async fn delete_project(
            &self,
            request: tonic::Request<super::DeleteProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteProjectResponse>,
            tonic::Status,
        >;
        async fn delete_service(
            &self,
            request: tonic::Request<super::DeleteServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteServiceResponse>,
            tonic::Status,
        >;
        async fn delete_service_instance(
            &self,
            request: tonic::Request<super::DeleteServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteServiceInstanceResponse>,
            tonic::Status,
        >;
        async fn delete_ssh_key(
            &self,
            request: tonic::Request<super::DeleteSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteSshKeyResponse>,
            tonic::Status,
        >;
        async fn find_account(
            &self,
            request: tonic::Request<super::FindAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindAccountResponse>,
            tonic::Status,
        >;
        async fn find_api_key(
            &self,
            request: tonic::Request<super::FindApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindApiKeyResponse>,
            tonic::Status,
        >;
        async fn find_checkout_session(
            &self,
            request: tonic::Request<super::FindCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindCheckoutSessionResponse>,
            tonic::Status,
        >;
        async fn find_file(
            &self,
            request: tonic::Request<super::FindFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindFileResponse>,
            tonic::Status,
        >;
        async fn find_invite(
            &self,
            request: tonic::Request<super::FindInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindInviteResponse>,
            tonic::Status,
        >;
        async fn find_issue(
            &self,
            request: tonic::Request<super::FindIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindIssueResponse>,
            tonic::Status,
        >;
        async fn find_issue_comment(
            &self,
            request: tonic::Request<super::FindIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindIssueCommentResponse>,
            tonic::Status,
        >;
        async fn find_linked_account(
            &self,
            request: tonic::Request<super::FindLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindLinkedAccountResponse>,
            tonic::Status,
        >;
        async fn find_plan(
            &self,
            request: tonic::Request<super::FindPlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindPlanResponse>,
            tonic::Status,
        >;
        async fn find_project(
            &self,
            request: tonic::Request<super::FindProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindProjectResponse>,
            tonic::Status,
        >;
        async fn find_service(
            &self,
            request: tonic::Request<super::FindServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindServiceResponse>,
            tonic::Status,
        >;
        async fn find_service_instance(
            &self,
            request: tonic::Request<super::FindServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindServiceInstanceResponse>,
            tonic::Status,
        >;
        async fn find_ssh_key(
            &self,
            request: tonic::Request<super::FindSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindSshKeyResponse>,
            tonic::Status,
        >;
        async fn find_many_accounts(
            &self,
            request: tonic::Request<super::FindManyAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyAccountsResponse>,
            tonic::Status,
        >;
        async fn find_many_api_keys(
            &self,
            request: tonic::Request<super::FindManyApiKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyApiKeysResponse>,
            tonic::Status,
        >;
        async fn find_many_files(
            &self,
            request: tonic::Request<super::FindManyFilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyFilesResponse>,
            tonic::Status,
        >;
        async fn find_many_invites(
            &self,
            request: tonic::Request<super::FindManyInvitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyInvitesResponse>,
            tonic::Status,
        >;
        async fn find_many_issue_comments(
            &self,
            request: tonic::Request<super::FindManyIssueCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyIssueCommentsResponse>,
            tonic::Status,
        >;
        async fn find_many_issues(
            &self,
            request: tonic::Request<super::FindManyIssuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyIssuesResponse>,
            tonic::Status,
        >;
        async fn find_many_linked_accounts(
            &self,
            request: tonic::Request<super::FindManyLinkedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyLinkedAccountsResponse>,
            tonic::Status,
        >;
        async fn find_many_plans(
            &self,
            request: tonic::Request<super::FindManyPlansRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyPlansResponse>,
            tonic::Status,
        >;
        async fn find_many_projects(
            &self,
            request: tonic::Request<super::FindManyProjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyProjectsResponse>,
            tonic::Status,
        >;
        async fn find_many_service_instances(
            &self,
            request: tonic::Request<super::FindManyServiceInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyServiceInstancesResponse>,
            tonic::Status,
        >;
        async fn find_many_services(
            &self,
            request: tonic::Request<super::FindManyServicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManyServicesResponse>,
            tonic::Status,
        >;
        async fn find_many_ssh_keys(
            &self,
            request: tonic::Request<super::FindManySshKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindManySshKeysResponse>,
            tonic::Status,
        >;
        async fn generate(
            &self,
            request: tonic::Request<super::GenerateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateResponse>,
            tonic::Status,
        >;
        async fn get_server_info(
            &self,
            request: tonic::Request<super::GetServerInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServerInfoResponse>,
            tonic::Status,
        >;
        async fn import(
            &self,
            request: tonic::Request<super::ImportRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportResponse>, tonic::Status>;
        async fn login(
            &self,
            request: tonic::Request<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status>;
        async fn noop(
            &self,
            request: tonic::Request<super::NoopRequest>,
        ) -> std::result::Result<tonic::Response<super::NoopResponse>, tonic::Status>;
        async fn update_account(
            &self,
            request: tonic::Request<super::UpdateAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateAccountResponse>,
            tonic::Status,
        >;
        async fn update_api_key(
            &self,
            request: tonic::Request<super::UpdateApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateApiKeyResponse>,
            tonic::Status,
        >;
        async fn update_checkout_session(
            &self,
            request: tonic::Request<super::UpdateCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateCheckoutSessionResponse>,
            tonic::Status,
        >;
        async fn update_file(
            &self,
            request: tonic::Request<super::UpdateFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateFileResponse>,
            tonic::Status,
        >;
        async fn update_invite(
            &self,
            request: tonic::Request<super::UpdateInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateInviteResponse>,
            tonic::Status,
        >;
        async fn update_issue(
            &self,
            request: tonic::Request<super::UpdateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateIssueResponse>,
            tonic::Status,
        >;
        async fn update_issue_comment(
            &self,
            request: tonic::Request<super::UpdateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateIssueCommentResponse>,
            tonic::Status,
        >;
        async fn update_linked_account(
            &self,
            request: tonic::Request<super::UpdateLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateLinkedAccountResponse>,
            tonic::Status,
        >;
        async fn update_plan(
            &self,
            request: tonic::Request<super::UpdatePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePlanResponse>,
            tonic::Status,
        >;
        async fn update_project(
            &self,
            request: tonic::Request<super::UpdateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateProjectResponse>,
            tonic::Status,
        >;
        async fn update_service(
            &self,
            request: tonic::Request<super::UpdateServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateServiceResponse>,
            tonic::Status,
        >;
        async fn update_service_instance(
            &self,
            request: tonic::Request<super::UpdateServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateServiceInstanceResponse>,
            tonic::Status,
        >;
        async fn update_ssh_key(
            &self,
            request: tonic::Request<super::UpdateSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateSshKeyResponse>,
            tonic::Status,
        >;
        async fn validate_account(
            &self,
            request: tonic::Request<super::ValidateAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateAccountResponse>,
            tonic::Status,
        >;
        async fn validate_api_key(
            &self,
            request: tonic::Request<super::ValidateApiKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateApiKeyResponse>,
            tonic::Status,
        >;
        async fn validate_checkout_session(
            &self,
            request: tonic::Request<super::ValidateCheckoutSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateCheckoutSessionResponse>,
            tonic::Status,
        >;
        async fn validate_invite(
            &self,
            request: tonic::Request<super::ValidateInviteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateInviteResponse>,
            tonic::Status,
        >;
        async fn validate_issue(
            &self,
            request: tonic::Request<super::ValidateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateIssueResponse>,
            tonic::Status,
        >;
        async fn validate_issue_comment(
            &self,
            request: tonic::Request<super::ValidateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateIssueCommentResponse>,
            tonic::Status,
        >;
        async fn validate_linked_account(
            &self,
            request: tonic::Request<super::ValidateLinkedAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateLinkedAccountResponse>,
            tonic::Status,
        >;
        async fn validate_plan(
            &self,
            request: tonic::Request<super::ValidatePlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidatePlanResponse>,
            tonic::Status,
        >;
        async fn validate_project(
            &self,
            request: tonic::Request<super::ValidateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateProjectResponse>,
            tonic::Status,
        >;
        async fn validate_service(
            &self,
            request: tonic::Request<super::ValidateServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateServiceResponse>,
            tonic::Status,
        >;
        async fn validate_service_instance(
            &self,
            request: tonic::Request<super::ValidateServiceInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateServiceInstanceResponse>,
            tonic::Status,
        >;
        async fn validate_ssh_key(
            &self,
            request: tonic::Request<super::ValidateSshKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateSshKeyResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the DownloadFile method.
        type DownloadFileStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DownloadFileResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn download_file(
            &self,
            request: tonic::Request<super::DownloadFileRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::DownloadFileStream>,
            tonic::Status,
        >;
        async fn upload_file(
            &self,
            request: tonic::Request<tonic::Streaming<super::UploadFileRequest>>,
        ) -> std::result::Result<
            tonic::Response<super::UploadFileResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct UserServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> UserServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for UserServer<T>
    where
        T: User,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/saas_rs.user.v1.User/CreateAccount" => {
                    #[allow(non_camel_case_types)]
                    struct CreateAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::CreateAccountRequest>
                    for CreateAccountSvc<T> {
                        type Response = super::CreateAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateApiKey" => {
                    #[allow(non_camel_case_types)]
                    struct CreateApiKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::CreateApiKeyRequest>
                    for CreateApiKeySvc<T> {
                        type Response = super::CreateApiKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateApiKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_api_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateApiKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateCheckoutSession" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCheckoutSessionSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::CreateCheckoutSessionRequest>
                    for CreateCheckoutSessionSvc<T> {
                        type Response = super::CreateCheckoutSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCheckoutSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_checkout_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateCheckoutSessionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateInvite" => {
                    #[allow(non_camel_case_types)]
                    struct CreateInviteSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::CreateInviteRequest>
                    for CreateInviteSvc<T> {
                        type Response = super::CreateInviteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateInviteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_invite(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateInviteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateIssue" => {
                    #[allow(non_camel_case_types)]
                    struct CreateIssueSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::CreateIssueRequest>
                    for CreateIssueSvc<T> {
                        type Response = super::CreateIssueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateIssueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_issue(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateIssueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateIssueComment" => {
                    #[allow(non_camel_case_types)]
                    struct CreateIssueCommentSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::CreateIssueCommentRequest>
                    for CreateIssueCommentSvc<T> {
                        type Response = super::CreateIssueCommentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateIssueCommentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_issue_comment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateIssueCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateLinkedAccount" => {
                    #[allow(non_camel_case_types)]
                    struct CreateLinkedAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::CreateLinkedAccountRequest>
                    for CreateLinkedAccountSvc<T> {
                        type Response = super::CreateLinkedAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateLinkedAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_linked_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateLinkedAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreatePlan" => {
                    #[allow(non_camel_case_types)]
                    struct CreatePlanSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::CreatePlanRequest>
                    for CreatePlanSvc<T> {
                        type Response = super::CreatePlanResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreatePlanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_plan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreatePlanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateProject" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProjectSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::CreateProjectRequest>
                    for CreateProjectSvc<T> {
                        type Response = super::CreateProjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateProjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_project(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateService" => {
                    #[allow(non_camel_case_types)]
                    struct CreateServiceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::CreateServiceRequest>
                    for CreateServiceSvc<T> {
                        type Response = super::CreateServiceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateServiceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_service(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateServiceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateServiceInstance" => {
                    #[allow(non_camel_case_types)]
                    struct CreateServiceInstanceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::CreateServiceInstanceRequest>
                    for CreateServiceInstanceSvc<T> {
                        type Response = super::CreateServiceInstanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateServiceInstanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_service_instance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateServiceInstanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/CreateSshKey" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSshKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::CreateSshKeyRequest>
                    for CreateSshKeySvc<T> {
                        type Response = super::CreateSshKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSshKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::create_ssh_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSshKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteApiKey" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteApiKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::DeleteApiKeyRequest>
                    for DeleteApiKeySvc<T> {
                        type Response = super::DeleteApiKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteApiKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_api_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteApiKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteCheckoutSession" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteCheckoutSessionSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::DeleteCheckoutSessionRequest>
                    for DeleteCheckoutSessionSvc<T> {
                        type Response = super::DeleteCheckoutSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteCheckoutSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_checkout_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteCheckoutSessionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteFile" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteFileSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::DeleteFileRequest>
                    for DeleteFileSvc<T> {
                        type Response = super::DeleteFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteInvite" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteInviteSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::DeleteInviteRequest>
                    for DeleteInviteSvc<T> {
                        type Response = super::DeleteInviteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteInviteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_invite(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteInviteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteIssue" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteIssueSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::DeleteIssueRequest>
                    for DeleteIssueSvc<T> {
                        type Response = super::DeleteIssueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteIssueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_issue(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteIssueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteIssueComment" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteIssueCommentSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::DeleteIssueCommentRequest>
                    for DeleteIssueCommentSvc<T> {
                        type Response = super::DeleteIssueCommentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteIssueCommentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_issue_comment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteIssueCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteLinkedAccount" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteLinkedAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::DeleteLinkedAccountRequest>
                    for DeleteLinkedAccountSvc<T> {
                        type Response = super::DeleteLinkedAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteLinkedAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_linked_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteLinkedAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeletePlan" => {
                    #[allow(non_camel_case_types)]
                    struct DeletePlanSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::DeletePlanRequest>
                    for DeletePlanSvc<T> {
                        type Response = super::DeletePlanResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeletePlanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_plan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeletePlanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteProject" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteProjectSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::DeleteProjectRequest>
                    for DeleteProjectSvc<T> {
                        type Response = super::DeleteProjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteProjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_project(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteProjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteService" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteServiceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::DeleteServiceRequest>
                    for DeleteServiceSvc<T> {
                        type Response = super::DeleteServiceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteServiceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_service(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteServiceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteServiceInstance" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteServiceInstanceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::DeleteServiceInstanceRequest>
                    for DeleteServiceInstanceSvc<T> {
                        type Response = super::DeleteServiceInstanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteServiceInstanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_service_instance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteServiceInstanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DeleteSshKey" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSshKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::DeleteSshKeyRequest>
                    for DeleteSshKeySvc<T> {
                        type Response = super::DeleteSshKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSshKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::delete_ssh_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSshKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindAccount" => {
                    #[allow(non_camel_case_types)]
                    struct FindAccountSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindAccountRequest>
                    for FindAccountSvc<T> {
                        type Response = super::FindAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindApiKey" => {
                    #[allow(non_camel_case_types)]
                    struct FindApiKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindApiKeyRequest>
                    for FindApiKeySvc<T> {
                        type Response = super::FindApiKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindApiKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_api_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindApiKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindCheckoutSession" => {
                    #[allow(non_camel_case_types)]
                    struct FindCheckoutSessionSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindCheckoutSessionRequest>
                    for FindCheckoutSessionSvc<T> {
                        type Response = super::FindCheckoutSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindCheckoutSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_checkout_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindCheckoutSessionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindFile" => {
                    #[allow(non_camel_case_types)]
                    struct FindFileSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindFileRequest>
                    for FindFileSvc<T> {
                        type Response = super::FindFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindInvite" => {
                    #[allow(non_camel_case_types)]
                    struct FindInviteSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindInviteRequest>
                    for FindInviteSvc<T> {
                        type Response = super::FindInviteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindInviteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_invite(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindInviteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindIssue" => {
                    #[allow(non_camel_case_types)]
                    struct FindIssueSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindIssueRequest>
                    for FindIssueSvc<T> {
                        type Response = super::FindIssueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindIssueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_issue(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindIssueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindIssueComment" => {
                    #[allow(non_camel_case_types)]
                    struct FindIssueCommentSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindIssueCommentRequest>
                    for FindIssueCommentSvc<T> {
                        type Response = super::FindIssueCommentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindIssueCommentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_issue_comment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindIssueCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindLinkedAccount" => {
                    #[allow(non_camel_case_types)]
                    struct FindLinkedAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindLinkedAccountRequest>
                    for FindLinkedAccountSvc<T> {
                        type Response = super::FindLinkedAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindLinkedAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_linked_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindLinkedAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindPlan" => {
                    #[allow(non_camel_case_types)]
                    struct FindPlanSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindPlanRequest>
                    for FindPlanSvc<T> {
                        type Response = super::FindPlanResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindPlanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_plan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindPlanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindProject" => {
                    #[allow(non_camel_case_types)]
                    struct FindProjectSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindProjectRequest>
                    for FindProjectSvc<T> {
                        type Response = super::FindProjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindProjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_project(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindProjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindService" => {
                    #[allow(non_camel_case_types)]
                    struct FindServiceSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindServiceRequest>
                    for FindServiceSvc<T> {
                        type Response = super::FindServiceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindServiceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_service(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindServiceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindServiceInstance" => {
                    #[allow(non_camel_case_types)]
                    struct FindServiceInstanceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindServiceInstanceRequest>
                    for FindServiceInstanceSvc<T> {
                        type Response = super::FindServiceInstanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindServiceInstanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_service_instance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindServiceInstanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindSshKey" => {
                    #[allow(non_camel_case_types)]
                    struct FindSshKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::FindSshKeyRequest>
                    for FindSshKeySvc<T> {
                        type Response = super::FindSshKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindSshKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_ssh_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindSshKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyAccountsSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyAccountsRequest>
                    for FindManyAccountsSvc<T> {
                        type Response = super::FindManyAccountsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyAccountsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_accounts(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyApiKeys" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyApiKeysSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyApiKeysRequest>
                    for FindManyApiKeysSvc<T> {
                        type Response = super::FindManyApiKeysResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyApiKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_api_keys(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyApiKeysSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyFiles" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyFilesSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyFilesRequest>
                    for FindManyFilesSvc<T> {
                        type Response = super::FindManyFilesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyFilesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_files(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyFilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyInvites" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyInvitesSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyInvitesRequest>
                    for FindManyInvitesSvc<T> {
                        type Response = super::FindManyInvitesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyInvitesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_invites(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyInvitesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyIssueComments" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyIssueCommentsSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyIssueCommentsRequest>
                    for FindManyIssueCommentsSvc<T> {
                        type Response = super::FindManyIssueCommentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyIssueCommentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_issue_comments(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyIssueCommentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyIssues" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyIssuesSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyIssuesRequest>
                    for FindManyIssuesSvc<T> {
                        type Response = super::FindManyIssuesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyIssuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_issues(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyIssuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyLinkedAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyLinkedAccountsSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyLinkedAccountsRequest>
                    for FindManyLinkedAccountsSvc<T> {
                        type Response = super::FindManyLinkedAccountsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyLinkedAccountsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_linked_accounts(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyLinkedAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyPlans" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyPlansSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyPlansRequest>
                    for FindManyPlansSvc<T> {
                        type Response = super::FindManyPlansResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyPlansRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_plans(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyPlansSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyProjects" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyProjectsSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyProjectsRequest>
                    for FindManyProjectsSvc<T> {
                        type Response = super::FindManyProjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyProjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_projects(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyProjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyServiceInstances" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyServiceInstancesSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyServiceInstancesRequest>
                    for FindManyServiceInstancesSvc<T> {
                        type Response = super::FindManyServiceInstancesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::FindManyServiceInstancesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_service_instances(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyServiceInstancesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManyServices" => {
                    #[allow(non_camel_case_types)]
                    struct FindManyServicesSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManyServicesRequest>
                    for FindManyServicesSvc<T> {
                        type Response = super::FindManyServicesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManyServicesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_services(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManyServicesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/FindManySshKeys" => {
                    #[allow(non_camel_case_types)]
                    struct FindManySshKeysSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::FindManySshKeysRequest>
                    for FindManySshKeysSvc<T> {
                        type Response = super::FindManySshKeysResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindManySshKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::find_many_ssh_keys(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindManySshKeysSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/Generate" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::GenerateRequest>
                    for GenerateSvc<T> {
                        type Response = super::GenerateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::generate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/GetServerInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetServerInfoSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::GetServerInfoRequest>
                    for GetServerInfoSvc<T> {
                        type Response = super::GetServerInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetServerInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::get_server_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServerInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/Import" => {
                    #[allow(non_camel_case_types)]
                    struct ImportSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::ImportRequest>
                    for ImportSvc<T> {
                        type Response = super::ImportResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ImportRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::import(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ImportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/Login" => {
                    #[allow(non_camel_case_types)]
                    struct LoginSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::LoginRequest>
                    for LoginSvc<T> {
                        type Response = super::LoginResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LoginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::login(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LoginSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/Noop" => {
                    #[allow(non_camel_case_types)]
                    struct NoopSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::NoopRequest>
                    for NoopSvc<T> {
                        type Response = super::NoopResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NoopRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::noop(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NoopSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateAccount" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::UpdateAccountRequest>
                    for UpdateAccountSvc<T> {
                        type Response = super::UpdateAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateApiKey" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateApiKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::UpdateApiKeyRequest>
                    for UpdateApiKeySvc<T> {
                        type Response = super::UpdateApiKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateApiKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_api_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateApiKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateCheckoutSession" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateCheckoutSessionSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::UpdateCheckoutSessionRequest>
                    for UpdateCheckoutSessionSvc<T> {
                        type Response = super::UpdateCheckoutSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateCheckoutSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_checkout_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateCheckoutSessionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateFile" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateFileSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::UpdateFileRequest>
                    for UpdateFileSvc<T> {
                        type Response = super::UpdateFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateInvite" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateInviteSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::UpdateInviteRequest>
                    for UpdateInviteSvc<T> {
                        type Response = super::UpdateInviteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateInviteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_invite(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateInviteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateIssue" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateIssueSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::UpdateIssueRequest>
                    for UpdateIssueSvc<T> {
                        type Response = super::UpdateIssueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateIssueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_issue(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateIssueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateIssueComment" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateIssueCommentSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::UpdateIssueCommentRequest>
                    for UpdateIssueCommentSvc<T> {
                        type Response = super::UpdateIssueCommentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateIssueCommentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_issue_comment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateIssueCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateLinkedAccount" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateLinkedAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::UpdateLinkedAccountRequest>
                    for UpdateLinkedAccountSvc<T> {
                        type Response = super::UpdateLinkedAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateLinkedAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_linked_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateLinkedAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdatePlan" => {
                    #[allow(non_camel_case_types)]
                    struct UpdatePlanSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::UpdatePlanRequest>
                    for UpdatePlanSvc<T> {
                        type Response = super::UpdatePlanResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdatePlanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_plan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdatePlanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateProject" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateProjectSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::UpdateProjectRequest>
                    for UpdateProjectSvc<T> {
                        type Response = super::UpdateProjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateProjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_project(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateProjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateService" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateServiceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::UpdateServiceRequest>
                    for UpdateServiceSvc<T> {
                        type Response = super::UpdateServiceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateServiceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_service(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateServiceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateServiceInstance" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateServiceInstanceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::UpdateServiceInstanceRequest>
                    for UpdateServiceInstanceSvc<T> {
                        type Response = super::UpdateServiceInstanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateServiceInstanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_service_instance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateServiceInstanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UpdateSshKey" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSshKeySvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::UpdateSshKeyRequest>
                    for UpdateSshKeySvc<T> {
                        type Response = super::UpdateSshKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSshKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::update_ssh_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateSshKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateAccount" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateAccountRequest>
                    for ValidateAccountSvc<T> {
                        type Response = super::ValidateAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateApiKey" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateApiKeySvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateApiKeyRequest>
                    for ValidateApiKeySvc<T> {
                        type Response = super::ValidateApiKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateApiKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_api_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateApiKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateCheckoutSession" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateCheckoutSessionSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateCheckoutSessionRequest>
                    for ValidateCheckoutSessionSvc<T> {
                        type Response = super::ValidateCheckoutSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ValidateCheckoutSessionRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_checkout_session(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateCheckoutSessionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateInvite" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateInviteSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateInviteRequest>
                    for ValidateInviteSvc<T> {
                        type Response = super::ValidateInviteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateInviteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_invite(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateInviteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateIssue" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateIssueSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateIssueRequest>
                    for ValidateIssueSvc<T> {
                        type Response = super::ValidateIssueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateIssueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_issue(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateIssueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateIssueComment" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateIssueCommentSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateIssueCommentRequest>
                    for ValidateIssueCommentSvc<T> {
                        type Response = super::ValidateIssueCommentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateIssueCommentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_issue_comment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateIssueCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateLinkedAccount" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateLinkedAccountSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateLinkedAccountRequest>
                    for ValidateLinkedAccountSvc<T> {
                        type Response = super::ValidateLinkedAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateLinkedAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_linked_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateLinkedAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidatePlan" => {
                    #[allow(non_camel_case_types)]
                    struct ValidatePlanSvc<T: User>(pub Arc<T>);
                    impl<T: User> tonic::server::UnaryService<super::ValidatePlanRequest>
                    for ValidatePlanSvc<T> {
                        type Response = super::ValidatePlanResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidatePlanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_plan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidatePlanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateProject" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateProjectSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateProjectRequest>
                    for ValidateProjectSvc<T> {
                        type Response = super::ValidateProjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateProjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_project(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateProjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateService" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateServiceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateServiceRequest>
                    for ValidateServiceSvc<T> {
                        type Response = super::ValidateServiceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateServiceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_service(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateServiceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateServiceInstance" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateServiceInstanceSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateServiceInstanceRequest>
                    for ValidateServiceInstanceSvc<T> {
                        type Response = super::ValidateServiceInstanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ValidateServiceInstanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_service_instance(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateServiceInstanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/ValidateSshKey" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateSshKeySvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::UnaryService<super::ValidateSshKeyRequest>
                    for ValidateSshKeySvc<T> {
                        type Response = super::ValidateSshKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateSshKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::validate_ssh_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateSshKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/DownloadFile" => {
                    #[allow(non_camel_case_types)]
                    struct DownloadFileSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::ServerStreamingService<super::DownloadFileRequest>
                    for DownloadFileSvc<T> {
                        type Response = super::DownloadFileResponse;
                        type ResponseStream = T::DownloadFileStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DownloadFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::download_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DownloadFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/saas_rs.user.v1.User/UploadFile" => {
                    #[allow(non_camel_case_types)]
                    struct UploadFileSvc<T: User>(pub Arc<T>);
                    impl<
                        T: User,
                    > tonic::server::ClientStreamingService<super::UploadFileRequest>
                    for UploadFileSvc<T> {
                        type Response = super::UploadFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::UploadFileRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as User>::upload_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for UserServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "saas_rs.user.v1.User";
    impl<T> tonic::server::NamedService for UserServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
